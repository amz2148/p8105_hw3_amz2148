---
title: "p8105_hw3_amz2148"
output: github_document
---

Homework 3

# Problem 0

```{r load_libraries}
library(tidyverse) #loads tidyverse package
library(patchwork) #loads patchwork package
library(ggridges) #loads ggridges package
```

```{r setup}
knitr::opts_chunk$set(echo = TRUE) #shows all code chunks
knitr::opts_chunk$set(
  fig.width = 7,
  fig.asp = .6,
  out.width = "90%")

theme_set(theme_minimal() + theme(legend.position = "bottom"))
```

# Problem 1


# Problem 2

First, we load, tidy, and otherwise wrangle the data. The final dataset includes all originally observed variables and values; has useful variable names; includes a weekday vs weekend variable; and encodes data with reasonable variable classes.

```{r load_activity}
activity = 
  read_csv("data/accel_data.csv") %>% #loads csv file
  janitor::clean_names() %>% #cleans variable names
    pivot_longer(
    activity_1:activity_1440,
    names_to = "minute", 
    values_to = "activity_lvl") %>% #tidies data into long format
  mutate(day_type = case_when(day == "Saturday" | day == "Sunday" ~ "weekend", day != "Saturday" | day == "Sunday" ~ "weekday")) %>% #creates day_type variable
  mutate(minute = gsub("[A-z]","",minute))  %>% #removes "activity_" prefix from minute variable
  mutate(day = as.factor(day), day_type = as.factor(day_type), minute = as.numeric(minute)) %>% #converts character variables to factor or dbl
  select(week, day_id, day, day_type, minute, activity_lvl) %>% #reorders columns
  arrange(week, day_id, minute) #arranges data by certain observations
```

In the resulting dataset, there are ``r nrow(activity)`` rows (observations) and ``r ncol(activity)`` columns (variables). The variables' names are ``r names(activity)``. The ``week`` variable assigns a numeric value to which week the observation is from, ranging from ``r min(activity$week, na.rm = TRUE)`` to ``r max(activity$week, na.rm = TRUE)``. The ``day_id`` variable assigns a numeric value to which day the observation is from, ranging from ``r min(activity$day_id, na.rm = TRUE)`` to ``r max(activity$day_id, na.rm = TRUE)``. The ``day`` variable states the day of the week associated with the observation and ``day_type`` states whether the observation occurred on a weekday or weekend. The ``minute`` variable shows what minute of the day the observation is from, ranging from ``r min(activity$minute, na.rm = TRUE)`` (starting at midnight) to ``r max(activity$minute, na.rm = TRUE)`` (just before midnight). Finally, the ``activity_lvl`` variable (with a median value of ``r median(activity$activity_lvl, na.rm = TRUE) ``) gives the activity count associated with each observation as measured by the accelerometer.


Traditional analyses of accelerometer data focus on the total activity over the day. Using the tidied dataset, we aggregate across minutes to create a total activity variable for each day, and create a table showing these totals. 

```{r aggregate_byday}
activity %>% 
  mutate(day = factor(day, levels = c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"))) %>% 
  group_by(week, day) %>% 
  summarize(
    total_activity = sum(activity_lvl)) %>% 
  pivot_wider(
    names_from = "day", 
    values_from = "total_activity") %>% 
  knitr::kable(digits = 0)
```

A table of total activity for each day reveals a few possible trends. The days toward the middle of each week (Tuesday, Wednesday, and Thursday) have fairly consistent, middle-of-the-range total activity levels (around 400,000 units per day). Meanwhile, the days at/around the weekend (Friday - Monday) have more variable total activity levels ranging from both very high (>600,000 units) to very low (around or less than 100,000 units). There are also a few days when likely no activity occurred (Saturday of weeks 4 and 5), evidenced by the fact that the total activity level was equal to 1440, which is the value outputted when every minute of the day had an activity level of 1. This may mean the individual was not wearing the accelerometer and thus this could be erroneous data. Furthermore, each week with the exception of week 4 has one day with an activity level above 600,000 units - suggesting that the day on which the individual may have not worn the device that week (Saturday) is the missing "highly active day" of this week (though this is by no means proven by the data).


Finally, we create a single-panel plot that shows the 24-hour activity time courses for each day and uses color to indicate day of the week. 

```{r activity_plot}
activity %>% 
  mutate(day = factor(day, levels = c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"))) %>% 
  group_by(day, minute) %>% 
  ggplot(aes(x = minute, y = activity_lvl)) + 
    geom_line(aes(color = day), alpha = .4) +
    theme(legend.position = "bottom") +
  labs(
    title = "Activity Count Every Minute by Day of the Week",
    x = "Minute",
    y = "Activity Count",
    caption = "Data from Advanced Cardiac Care Center of Columbia University Medical Center.")
```

Based on this graph, one can see that most activity count values are fairly low, generally below ~2000 units each minute. There is also lower activity seen in the early parts of the day (before around minute 500). There are spikes throughout the day, but these are primarily clustered around the middle of the day (~minute 700) and in the evening (~minute 1250). Furthermore, when examining these aforementioned clustered spikes, we can see many noon spikes on Sundays and many evening spikes on Fridays. Meanwhile, other smaller patterns are visible as well, such as consistent medium-level spiking on Saturdays around minute 1000. These patterns could offer clues about the individual's daily habits and activities. For example, it is possible that the individual usually goes out on Friday nights and walks to lunch on Sundays. However, is seems less likely that the individual walks/cycles to work every day as there are no consistent weekday spikes around 9am (minute 540) and 5pm (1000), but perhaps the person does so on some days, since a few spikes are seen around those values. But to know detailed information such as this, we would need to know more about the person's activities, as the graph can only provide suggestions but not definitive conclusions, since many other variables could be contributing to the trends we see.


# Problem 3

First, we load the NY NOAA dataset from the ``p8105.datasets`` package.

```{r load_NOAA}
library(p8105.datasets)
data("ny_noaa", package = "p8105.datasets")
```

Upon loading the ``ny_noaa`` dataset, before tidying or altering the data in any way, we see that it contains ``r nrow(ny_noaa)`` rows (observations) and ``r ncol(ny_noaa)`` columns (variables). The variables' names are ``r names(ny_noaa)``. The ``id`` variable contains the alphanumeric ID of weather station associated with each observation, while the ``date`` variable encodes the date of the observation. ``prcp`` gives precipitation in tenths of mm, ``snow`` gives snowfall in mm, ``snwd`` gives snow depth in mm, ``tmax`` gives the maximum temperature in tenths of degrees C, and ``tmin`` gives the minimum temperature in tenths of degrees C. Missing observations in this dataset, however, are a major issue. There are ``r sum(is.na(ny_noaa$id))`` missing IDs and ``r sum(is.na(ny_noaa$date))`` missing dates, but there are ``r sum(is.na(ny_noaa$prcp))`` missing prcp values, ``r sum(is.na(ny_noaa$snow))`` missing snow values, ``r sum(is.na(ny_noaa$snwd))`` missing snwd values, ``r sum(is.na(ny_noaa$tmax))`` missing tmax values, and ``r sum(is.na(ny_noaa$tmin))`` missing tmin values.


Next we will do some data cleaning. We create separate variables for year, month, and day. We also ensure observations for temperature, precipitation, and snowfall are given in reasonable units.

```{r cleaning_NOAA}
noaa_snow = 
  ny_noaa %>%
    janitor::clean_names() %>% 
  separate(date, into = c("year", "month", "day"), sep = '-') %>% #separates date variable into year, month, day variables
  mutate(id = as.factor(id), month = as.numeric(month), year = as.numeric(year), day = as.numeric(day), prcp = as.numeric(prcp), snow = as.numeric(snow), snwd = as.numeric(snow), tmax = as.numeric(tmax), tmin = as.numeric(tmin)) %>% #converts all variables to proper classes
  mutate(month = month.abb[month]) %>% #replaces month number with name
  mutate(month = factor(month, levels = month.abb)) %>% #converts month name to factor variable
  arrange(id, year, month, day) %>% 
  pivot_longer(
    tmax:tmin,
    names_to = "temperature", 
    values_to = "degrees_c") %>% #tidies data into long format
  mutate(prcp_mm = prcp / 10, degrees_c = degrees_c / 10) %>% #fixes units of prcp and degrees_c variables (converts them to mm and C respectively)
  group_by(snow) %>%
  summarize(
    n_obs = n() / 2) %>%
  arrange(desc(n_obs))

head(noaa_snow)
```

The 5 most commonly observed values for snow (snowfall in mm) are: 0mm (2008508 observations), NA (381221 obs), 25mm (31022 obs), 13mm (23095 obs), and 51mm (18274 obs). It makes sense that the most common value is 0, because these observations come from various parts of the year, and it usually does not snow year-round in New York, thus a large portion of days in the year have no snow. Furthermore, the second most common value is NA. The dataset description states "about one half of the stations report precipitation only" so again it makes sense that a high frequency of observations have no associated snowfall report. The largest snowfall value in the dataset is 10160mm (~10 meters), however, we know logically that likely does not happen across all of New York (and furthermore, such large amounts of snowfall are likely anomalies even in very cold areas), so therefore it again makes logical sense that the next most common values are fairly small. 


Next, we make a two-panel plot showing the average max temperature in January and in July in each station across years. 

```{r tmax_linegraph}
janjune = 
  ny_noaa %>%
    janitor::clean_names() %>% 
  separate(date, into = c("year", "month", "day"), sep = '-') %>% #separates date variable into year, month, day variables
  mutate(id = as.factor(id), month = as.numeric(month), year = as.numeric(year), day = as.numeric(day), prcp = as.numeric(prcp), snow = as.numeric(snow), snwd = as.numeric(snow), tmax = as.numeric(tmax), tmin = as.numeric(tmin)) %>% #converts all variables to proper classes
  mutate(month = month.abb[month]) %>% #replaces month number with name
  mutate(month = factor(month, levels = month.abb)) %>% #converts month name to factor variable
  arrange(id, year, month, day) %>% 
  pivot_longer(
    tmax:tmin,
    names_to = "temperature", 
    values_to = "degrees_c") %>% #tidies data into long format
  mutate(prcp_mm = prcp / 10, degrees_c = degrees_c / 10) %>% #fixes units of prcp and degrees_c variables (converts them to mm and C respectively)
  filter(month == "Jan" | month == "Jul") %>% 
  filter(temperature == "tmax") %>% 
  group_by(id, year, month) %>% 
  summarize(
    tmax_mean = mean(degrees_c, na.rm = TRUE)) %>% 
  arrange(id, year, month) %>% 
  ggplot(aes(x = year, y = tmax_mean, group = id)) + 
    geom_line() + facet_grid(. ~ month) + theme(legend.position = "none") +
    labs(
      title = "Mean Maximum Temperature Recorded in January and July (1981-2010)",
      x = "Year",
      y = "Monthly mean maxiumum temperature (C)",
      caption = "Data from NY NOAA.") + theme(legend.position = "none")

janjune
```

Note: All NY weather stations from this dataset with data for maximum temperature in January/July are included (but NA values are excluded from mean calculations). Due to the large number of stations, they are not color-coded in this graph."

When plotting the data in line-graph form, we can see that the monthly mean maximum temperatures for both January and July from 1981-2010 appear to follow a cyclical pattern. Looking at all weather stations together, the monthly mean maximum temperature appears to first increase steadily over 1-3 years, then hit a peak, then decrease steadily over 1-3 years, and repeat the cycle. However, due to the large amount of weather stations' data being plotted on top of one another, it is impossible to track the patterns of individual weather stations through the whole plot. Therefore, it could be that each weather station is cycling through the full vertical range of temperature values seen, or that some only cycle through the higher temperatures (e.g., 0-10 degrees C in January) while others only cycle through the lower temperatures (e.g., -10-0 degrees C in January). We can only see distinct lines in a few parts of the graph: most mid-range values at most years blend together due to the large number of weather stations. Our graph suggests that there are a few outliers (i.e., a very low January temp in 1982 around -13 C and a very low July temp in 1988 around 14 C). However, we cannot be sure which values are or are not outliers just by looking at the line graph as it does not visually mark the cutoff beyond which values are considered outliers (i.e., Q1 - (1.5 times the interquartile range) as well as Q3 + (1.5 times the interquartile range)).


Finally, we make a two-panel plot showing (i) tmax vs tmin for the full dataset (note that a scatterplot may not be the best option); and (ii) make a plot showing the distribution of snowfall values greater than 0 and less than 100 separately by year.

```{r twopanel_plot}
tmaxmin = 
  ny_noaa %>%
    janitor::clean_names() %>% 
    separate(date, into = c("year", "month", "day"), sep = '-') %>% #separates date variable into year, month, day variables
    mutate(id = as.factor(id), month = as.numeric(month), year = as.numeric(year), day = as.numeric(day), prcp = as.numeric(prcp), snow = as.numeric(snow), snwd = as.numeric(snow), tmax = as.numeric(tmax), tmin = as.numeric(tmin)) %>% #converts all variables to proper classes
    mutate(month = month.abb[month]) %>% #replaces month number with name
    mutate(month = factor(month, levels = month.abb)) %>% #converts month name to factor variable
    arrange(id, year, month, day) %>% 
    mutate(prcp_mm = prcp / 10, tmax_c = tmax / 10, tmin_c = tmin / 10) %>% #fixes units of prcp and degrees_c variables (converts them to mm and C respectively)
    ggplot(aes(x = tmin_c, y = tmax_c)) + geom_hex() +
      labs(
        title = "Max vs Min Temperature (1981-2010)",
        x = "Minimum Temperature (C)",
        y = "Maximum Temperature (C)",
        caption = "Data from NY NOAA.") + theme(legend.position = "right")

snowfall = 
  ny_noaa %>%
    janitor::clean_names() %>% 
    separate(date, into = c("year", "month", "day"), sep = '-') %>% #separates date variable into year, month, day variables
    mutate(id = as.factor(id), month = as.numeric(month), year = as.factor(year), day = as.numeric(day), prcp = as.numeric(prcp), snow = as.numeric(snow), snwd = as.numeric(snow), tmax = as.numeric(tmax), tmin = as.numeric(tmin)) %>% #converts all variables to proper classes
    mutate(month = month.abb[month]) %>% #replaces month number with name
    mutate(month = factor(month, levels = month.abb)) %>% #converts month name to factor variable
    arrange(id, year, month, day) %>% 
    mutate(prcp_mm = prcp / 10, tmax_c = tmax / 10, tmin_c = tmin / 10) %>% #fixes units of prcp and degrees_c variables (converts them to mm and C respectively)
    filter(snow > 0, snow < 100) %>% 
  ggplot(aes(x = snow, y = year)) + geom_density_ridges(scale = 1) + xlim(0, 100) + 
      labs(
        title = "0-100mm Snowfall Distribution by Year (1981-2010)",
        x = "Snowfall (mm)",
        y = "Year",
        caption = "Data from NY NOAA.")
    
tmaxmin + snowfall
```

Plotting the maximum vs. minimum temperatures of the whole NY NOAA dataset reveals a fairly direct, positive relationship between the two. This can be seen by the high concentration of data points in the center of the two-dimensional hexagonal heatmap (colored light blue) in the output above. However, it seems that the tmax and tmin variables

```{r tmaxmin_table}
tmaxmin_table = 
  ny_noaa %>%
    janitor::clean_names() %>% 
    separate(date, into = c("year", "month", "day"), sep = '-') %>% #separates date variable into year, month, day variables
    mutate(id = as.factor(id), month = as.numeric(month), year = as.numeric(year), day = as.numeric(day), prcp = as.numeric(prcp), snow = as.numeric(snow), snwd = as.numeric(snow), tmax = as.numeric(tmax), tmin = as.numeric(tmin)) %>% #converts all variables to proper classes
    mutate(month = month.abb[month]) %>% #replaces month number with name
    mutate(month = factor(month, levels = month.abb)) %>% #converts month name to factor variable
    mutate(prcp_mm = prcp / 10, tmax_c = tmax / 10, tmin_c = tmin / 10) %>% 
    select(id, year, month, day, tmax, tmin, tmax_c, tmin_c)
```
